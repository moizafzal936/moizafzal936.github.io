<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Payment Infrastructure Case Study — Mueez Afzal</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Crimson+Pro:wght@400;600;700&display=swap" rel="stylesheet">

<style>
:root {
  --bg: #0a0e14;
  --bg-elevated: #151920;
  --panel: #1a1f28;
  --panel-hover: #242933;
  --text: #e6e8eb;
  --text-muted: #8a8e98;
  --accent-primary: #00d4aa;
  --accent-secondary: #ff6b6b;
  --accent-tertiary: #ffd93d;
  --border: #2a2f3a;
  --code-bg: #0f1419;

  --font-display: 'JetBrains Mono', monospace;
  --font-body: 'Crimson Pro', serif;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: var(--font-body);
  background: var(--bg);
  color: var(--text);
  line-height: 1.8;
  font-size: 18px;
}

.container {
  max-width: 900px;
  margin: 0 auto;
  padding: 60px 30px;
}

.back-link {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  font-family: var(--font-display);
  font-size: 0.9rem;
  color: var(--accent-primary);
  text-decoration: none;
  margin-bottom: 40px;
  transition: gap 0.3s ease;
}

.back-link:hover {
  gap: 12px;
}

.hero {
  margin-bottom: 60px;
  padding-bottom: 40px;
  border-bottom: 1px solid var(--border);
}

.case-title {
  font-family: var(--font-display);
  font-size: clamp(2rem, 5vw, 3rem);
  font-weight: 700;
  margin-bottom: 16px;
  line-height: 1.2;
  color: var(--accent-primary);
}

.case-subtitle {
  font-size: 1.3rem;
  color: var(--text-muted);
  margin-bottom: 30px;
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 24px;
  margin-top: 40px;
}

.metric-box {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 24px;
  text-align: center;
}

.metric-value {
  font-family: var(--font-display);
  font-size: 2.5rem;
  font-weight: 700;
  color: var(--accent-primary);
  display: block;
  margin-bottom: 8px;
}

.metric-value.negative {
  color: var(--accent-secondary);
}

.metric-value.business {
  color: var(--accent-tertiary);
}

.metric-label {
  font-size: 0.9rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.section {
  margin-bottom: 60px;
}

.section-title {
  font-family: var(--font-display);
  font-size: 1.8rem;
  font-weight: 700;
  margin-bottom: 24px;
  color: var(--accent-primary);
}

.section-content {
  color: var(--text);
  line-height: 1.8;
}

.section-content p {
  margin-bottom: 20px;
}

.section-content strong {
  color: var(--accent-primary);
  font-weight: 600;
}

.section-content em {
  color: var(--accent-secondary);
  font-style: normal;
}

.highlight-box {
  background: var(--panel);
  border-left: 4px solid var(--accent-primary);
  padding: 24px;
  margin: 30px 0;
  border-radius: 8px;
}

.code-block {
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 24px;
  margin: 30px 0;
  overflow-x: auto;
  font-family: var(--font-display);
  font-size: 0.9rem;
  line-height: 1.6;
  color: var(--text);
}

.code-block code {
  color: var(--text-muted);
}

.code-block .keyword {
  color: #ff6b6b;
}

.code-block .string {
  color: #00d4aa;
}

.code-block .comment {
  color: #64748b;
}

ul {
  margin: 20px 0;
  padding-left: 24px;
}

li {
  margin-bottom: 12px;
  color: var(--text-muted);
}

li strong {
  color: var(--text);
}

.architecture-diagram {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 40px;
  margin: 40px 0;
  text-align: center;
}

.architecture-diagram img {
  max-width: 100%;
  height: auto;
}

.lessons-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 24px;
  margin-top: 30px;
}

.lesson-card {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 24px;
}

.lesson-title {
  font-family: var(--font-display);
  font-size: 1.1rem;
  font-weight: 700;
  color: var(--accent-primary);
  margin-bottom: 12px;
}

.lesson-content {
  font-size: 0.95rem;
  color: var(--text-muted);
  line-height: 1.6;
}

@media (max-width: 640px) {
  .case-title {
    font-size: 1.8rem;
  }

  .section-title {
    font-size: 1.4rem;
  }

  .metrics-grid {
    grid-template-columns: 1fr;
  }
}
</style>
</head>

<body>
<div class="container">
  <a href="../index.html" class="back-link">← Back to Portfolio</a>

  <div class="hero">
    <h1 class="case-title">Stripe Payment Infrastructure</h1>
    <p class="case-subtitle">
      Architecting idempotent payment processing for $2.4M ARR with 99.98% reliability
    </p>

    <div class="metrics-grid">
      <div class="metric-box">
        <span class="metric-value negative">-87%</span>
        <span class="metric-label">Payment Incidents</span>
      </div>
      <div class="metric-box">
        <span class="metric-value">99.98%</span>
        <span class="metric-label">Billing Reliability</span>
      </div>
      <div class="metric-box">
        <span class="metric-value business">$2.4M</span>
        <span class="metric-label">ARR Processed</span>
      </div>
      <div class="metric-box">
        <span class="metric-value">500+</span>
        <span class="metric-label">Enterprise Customers</span>
      </div>
    </div>
  </div>

  <!-- PROBLEM -->
  <div class="section">
    <h2 class="section-title">The Problem</h2>
    <div class="section-content">
      <p>
        Our SaaS platform was processing <strong>$2.4M in annual recurring revenue</strong> through Stripe, serving 500+ enterprise customers.
        But our billing system was hemorrhaging money and trust.
      </p>

      <p>
        <em>The symptoms were brutal:</em>
      </p>

      <ul>
        <li><strong>Double charges:</strong> Customers getting billed twice due to webhook retries and race conditions</li>
        <li><strong>Webhook desync:</strong> Stripe events arriving out of order, causing invoice state mismatches</li>
        <li><strong>Silent failures:</strong> Payment failures not triggering dunning flows, leading to unintentional service for unpaid customers</li>
        <li><strong>Reconciliation nightmares:</strong> Weekly manual ledger checks consuming 6+ engineer-hours to catch discrepancies</li>
        <li><strong>Support escalations:</strong> 40+ billing-related tickets per month, many from enterprise accounts threatening churn</li>
      </ul>

      <div class="highlight-box">
        <p style="margin: 0;">
          <strong>The breaking point:</strong> A webhook race condition caused 23 enterprise customers to be double-charged on the same day.
          We issued $47K in refunds and nearly lost our largest customer ($180K ARR).
          The CEO told me: "Fix this or we're building our own billing system."
        </p>
      </div>

      <p>
        The root cause wasn't Stripe—it was our architecture. We were treating Stripe webhooks like reliable, ordered events.
        We weren't. Distributed systems don't give you those guarantees.
      </p>
    </div>
  </div>

  <!-- CONSTRAINTS -->
  <div class="section">
    <h2 class="section-title">Constraints & Challenges</h2>
    <div class="section-content">
      <p>
        This wasn't a greenfield rebuild. We had to fix a moving plane mid-flight.
      </p>

      <ul>
        <li><strong>Zero downtime requirement:</strong> Can't stop billing for 500+ customers during migration</li>
        <li><strong>Data consistency:</strong> Millions in historical transaction data must remain accurate</li>
        <li><strong>Team size:</strong> Solo ownership with support from 1 junior engineer</li>
        <li><strong>Timeline:</strong> 6 weeks to production-ready (board meeting deadline)</li>
        <li><strong>Scale:</strong> 12K+ webhooks/month, peak load of 200+ events during subscription renewal periods</li>
        <li><strong>Legacy code:</strong> 3-year-old codebase with tightly coupled payment logic across 8 controllers</li>
      </ul>

      <p>
        <em>Technical debt we inherited:</em> No event sourcing, no idempotency keys, webhooks handled in synchronous controllers,
        Stripe API calls scattered across the codebase with no retry logic, and manual SQL scripts for ledger reconciliation.
      </p>
    </div>
  </div>

  <!-- SOLUTION -->
  <div class="section">
    <h2 class="section-title">Architecture & Solution</h2>
    <div class="section-content">
      <p>
        I designed a <strong>three-layer defensive architecture</strong> treating every webhook as potentially duplicate, out-of-order, or delayed.
      </p>

      <h3 style="font-size: 1.3rem; margin: 30px 0 16px; color: var(--accent-primary);">
        Layer 1: Idempotent Webhook Processing
      </h3>

      <p>
        Every Stripe event gets a unique event ID. We store processed events in a <code>stripe_events</code> table with
        <code>event_id</code> as primary key. Before processing any webhook:
      </p>

      <div class="code-block">
<code><span class="comment"># Atomic idempotency check</span>
<span class="keyword">def</span> <span class="function">process_webhook</span>(event)
  <span class="keyword">return</span> <span class="keyword">if</span> StripeEvent.exists?(event_id: event.id)

  StripeEvent.transaction <span class="keyword">do</span>
    StripeEvent.create!(
      event_id: event.id,
      event_type: event.type,
      received_at: Time.current
    )

    <span class="comment"># Process event...</span>
    handle_event(event)
  <span class="keyword">end</span>
<span class="keyword">rescue</span> ActiveRecord::RecordNotUnique
  <span class="comment"># Race condition - another process handled it</span>
  Rails.logger.info <span class="string">"Duplicate event ignored: #{event.id}"</span>
<span class="keyword">end</span></code>
      </div>

      <p>
        This guarantees <strong>exactly-once processing</strong> even if Stripe retries webhooks (which it does, aggressively).
      </p>

      <h3 style="font-size: 1.3rem; margin: 30px 0 16px; color: var(--accent-primary);">
        Layer 2: Circuit Breaker Pattern
      </h3>

      <p>
        Stripe goes down. AWS has latency spikes. Network packets get dropped. We can't control external systems,
        but we can prevent cascading failures.
      </p>

      <div class="code-block">
<code><span class="comment"># Circuit breaker for Stripe API calls</span>
circuit_breaker = CircuitBreaker.new(
  failure_threshold: 5,
  timeout: 10.seconds,
  reset_timeout: 60.seconds
)

<span class="keyword">begin</span>
  circuit_breaker.call <span class="keyword">do</span>
    Stripe::PaymentIntent.create(
      amount: charge_amount,
      customer: stripe_customer_id,
      idempotency_key: <span class="string">"#{invoice.id}-#{attempt}"</span>
    )
  <span class="keyword">end</span>
<span class="keyword">rescue</span> CircuitBreaker::OpenError
  <span class="comment"># Circuit is open - fail fast, alert on-call</span>
  notify_oncall(<span class="string">"Stripe circuit breaker open"</span>)
  <span class="keyword">raise</span>
<span class="keyword">end</span></code>
      </div>

      <p>
        When Stripe's API response times spike, we open the circuit and fail fast instead of piling up timeouts.
        This saved us during Stripe's January 2024 outage (we didn't cascade).
      </p>

      <h3 style="font-size: 1.3rem; margin: 30px 0 16px; color: var(--accent-primary);">
        Layer 3: Reconciliation Workers
      </h3>

      <p>
        Even with idempotency and circuit breakers, distributed systems have edge cases. Webhooks get lost. Events arrive late.
        We run <strong>automated reconciliation jobs every 6 hours:</strong>
      </p>

      <ul>
        <li>Compare our invoice ledger against Stripe's API</li>
        <li>Flag discrepancies (missing webhooks, amount mismatches, status drift)</li>
        <li>Auto-heal for safe cases (webhook was lost but charge succeeded)</li>
        <li>Alert engineers for manual investigation (payment method declined but we marked as paid)</li>
      </ul>

      <p>
        This catches the 0.02% of edge cases our primary defenses miss. It's our safety net.
      </p>
    </div>
  </div>

  <!-- IMPLEMENTATION -->
  <div class="section">
    <h2 class="section-title">Implementation Details</h2>
    <div class="section-content">
      <h3 style="font-size: 1.3rem; margin: 30px 0 16px; color: var(--accent-primary);">
        Migration Strategy (Zero Downtime)
      </h3>

      <p>
        We couldn't flip a switch. We had to migrate incrementally while serving production traffic.
      </p>

      <p><strong>Week 1-2:</strong> Built new webhook processing layer, ran in parallel with legacy system (shadow mode).
      Logged discrepancies but didn't affect production data.</p>

      <p><strong>Week 3-4:</strong> Enabled new system for 10% of customers (low-risk accounts). Monitored for 2 weeks.
      Fixed 3 edge cases we didn't anticipate (subscription changes during trial periods, prorated upgrades, tax calculation race conditions).</p>

      <p><strong>Week 5:</strong> Rolled out to 100% of customers. Kept legacy system running in read-only mode for 2 weeks as safety backup.</p>

      <p><strong>Week 6:</strong> Decommissioned legacy code. Deleted 4,200 lines of webhook spaghetti.</p>

      <h3 style="font-size: 1.3rem; margin: 30px 0 16px; color: var(--accent-primary);">
        Observability & Monitoring
      </h3>

      <p>
        You can't fix what you can't see. We instrumented every layer:
      </p>

      <ul>
        <li><strong>Webhook latency:</strong> P50, P95, P99 processing times (alerting on P95 > 2s)</li>
        <li><strong>Event replay dashboard:</strong> Visualize duplicate events caught by idempotency layer</li>
        <li><strong>Circuit breaker metrics:</strong> Track open/closed state, failure rates, recovery times</li>
        <li><strong>Reconciliation alerts:</strong> Slack notifications for any ledger discrepancies requiring manual review</li>
        <li><strong>Business metrics:</strong> Daily ARR processed, failed payment rate, churn due to billing issues</li>
      </ul>

      <p>
        This wasn't vanity dashboards. Every metric had an SLO and an owner.
      </p>
    </div>
  </div>

  <!-- RESULTS -->
  <div class="section">
    <h2 class="section-title">Results & Impact</h2>
    <div class="section-content">
      <p>
        <strong>6 months post-launch:</strong>
      </p>

      <ul>
        <li><strong>87% reduction in payment incidents</strong> (from 23/month to 3/month, and those 3 were Stripe API outages beyond our control)</li>
        <li><strong>99.98% billing reliability</strong> (SLO: 99.95%), measured as successful charges / attempted charges</li>
        <li><strong>Zero double-charge incidents</strong> since deployment (previously averaging 4/month)</li>
        <li><strong>6 engineer-hours/week saved</strong> on manual reconciliation (now fully automated)</li>
        <li><strong>Support tickets down 73%</strong> (from 40/month to 11/month, most of which are user education)</li>
        <li><strong>$180K ARR retained</strong> from enterprise customer who was about to churn over billing issues</li>
      </ul>

      <div class="highlight-box">
        <p style="margin: 0;">
          <strong>The validation:</strong> During Stripe's 4-hour API outage in January 2024, our circuit breakers
          failed fast and our reconciliation workers automatically healed 98% of affected invoices once Stripe recovered.
          Zero customer complaints. Zero manual intervention.
        </p>
      </div>
    </div>
  </div>

  <!-- LESSONS LEARNED -->
  <div class="section">
    <h2 class="section-title">Lessons Learned</h2>
    <div class="lessons-grid">
      <div class="lesson-card">
        <h3 class="lesson-title">Idempotency > Debugging</h3>
        <p class="lesson-content">
          Building idempotent systems upfront is 10x cheaper than debugging race conditions at 3 AM.
          Treat every external event as potentially duplicate.
        </p>
      </div>

      <div class="lesson-card">
        <h3 class="lesson-title">Trust, But Verify</h3>
        <p class="lesson-content">
          Webhooks are not transactions. Events can arrive out of order, get lost, or duplicate.
          Always reconcile against source of truth.
        </p>
      </div>

      <div class="lesson-card">
        <h3 class="lesson-title">Fail Fast, Recover Automatically</h3>
        <p class="lesson-content">
          Circuit breakers prevent cascading failures. Reconciliation workers catch edge cases.
          Together, they make systems self-healing.
        </p>
      </div>

      <div class="lesson-card">
        <h3 class="lesson-title">Incremental Migrations Win</h3>
        <p class="lesson-content">
          Shadow mode → 10% rollout → 100% → decommission.
          Never bet the company on a big-bang deployment.
        </p>
      </div>

      <div class="lesson-card">
        <h3 class="lesson-title">Observability is Table Stakes</h3>
        <p class="lesson-content">
          You can't improve reliability without metrics.
          Every layer needs monitoring, SLOs, and alerts that wake humans for real problems.
        </p>
      </div>

      <div class="lesson-card">
        <h3 class="lesson-title">Payment Bugs are Existential</h3>
        <p class="lesson-content">
          Customers forgive slow pages. They don't forgive double charges.
          Payment infrastructure deserves your best defensive engineering.
        </p>
      </div>
    </div>
  </div>

  <div style="margin-top: 80px; padding-top: 40px; border-top: 1px solid var(--border); text-align: center;">
    <a href="../index.html" class="back-link" style="margin: 0;">← Back to Portfolio</a>
  </div>
</div>
</body>
</html>
